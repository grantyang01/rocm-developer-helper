#!/bin/bash
SELF_TAG="[$(basename ${BASH_SOURCE[0]})]"

# List architectures bundled in a .co file
# Usage: list-co <file.co>
list-co() {
    local co_file="$1"
    
    # Check if file argument provided
    if [[ -z "$co_file" ]]; then
        die "No file specified\nUsage: list-co <file.co>"
    fi
    
    # Check if file exists
    if [[ ! -f "$co_file" ]]; then
        die "File not found: $co_file"
    fi
    
    # Display file info
    log "File: $co_file"
    ls -lh "$co_file"
    echo ""
    
    # Check file type
    log "File Type:"
    file "$co_file"
    echo ""
    
    # List bundled architectures
    log "Bundled Architectures:"
    if clang-offload-bundler --type=o --list --input="$co_file" 2>/dev/null; then
        echo ""
        log "✓ File is bundled (use ub-co to extract)"
    else
        die "⚠ Not a bundled file (may already be unbundled ELF)"
    fi
}

# Unbundle a .co file to extract ELF for specific architecture
# Usage: ub-co <input.co> <output.elf> <target>
# Target should be copied from list-co output, e.g.:
#   hipv4-amdgcn-amd-amdhsa--gfx950
ub-co() {
    local input_co="$1"
    local output_elf="$2"
    local target="$3"
    
    # Unbundle
    log "Extracting $target to $output_elf..."
    if ! clang-offload-bundler --type=o --unbundle \
        --targets="$target" \
        --input="$input_co" \
        --output="$output_elf" 2>&1; then
        die "Usage: ub-co <input.co> <output.elf> <target>\n <target> can be copied and pasted from list-co output\n"
    fi
    
    # Verify output
    if [[ ! -f "$output_elf" ]]; then
        die "Output file not created: $output_elf"
    fi
    
    log "✓ Successfully unbundled"
    echo ""
    log "Output file:"
    ls -lh "$output_elf"
    echo ""
    
    log "File type:"
    file "$output_elf"
    echo ""
    
    # Count kernels
    local kernel_count=$(readelf -s "$output_elf" 2>/dev/null | grep FUNC | wc -l)
    log "Kernel count: $kernel_count"
    
    log "✓ Done! Use 'readelf -sW $output_elf | grep FUNC' to list kernels"
}

# Show kernel metadata from an unbundled ELF file
# Usage: show-kernel-meta <kernel_name> <elf_file>
# Example: show-kernel-meta "Custom_Cijk_Alik_Bljk_S_MX_B_BIAS_HA_S_SAV_NTD_SK3_UserArgs_MT256x256x32_MI16x16x1_shortname0_gfx950" kernel.elf
show-kernel-meta() {
    local kernel_name="$1"
    local elf_file="$2"
    
    if [[ -z "$kernel_name" || -z "$elf_file" ]]; then
        die "Usage: show-kernel-meta <kernel_name> <elf_file>\nExample: show-kernel-meta 'Custom_Cijk_Alik_...' kernel.elf"
    fi
    
    if [[ ! -f "$elf_file" ]]; then
        die "File not found: $elf_file"
    fi
    
    # Verify kernel exists
    if ! readelf -sW "$elf_file" 2>/dev/null | grep -q " FUNC .* $kernel_name$"; then
        die "Kernel not found in ELF: $kernel_name"
    fi
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    log "Kernel: $kernel_name"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    # Use llvm-readobj to get full metadata in YAML format
    # Save to temp file for processing
    local temp_meta="/tmp/show_kernel_meta_$$.txt"
    llvm-readobj -n "$elf_file" > "$temp_meta" 2>/dev/null
    
    # Find the line with our kernel's .name: field
    local name_line=$(grep -n "^    \.name:[[:space:]]*$kernel_name\$" "$temp_meta" | head -1 | cut -d: -f1)
    
    if [[ -z "$name_line" ]]; then
        rm -f "$temp_meta"
        log "⚠ No metadata found for kernel: $kernel_name"
        echo ""
        return
    fi
    
    # Find start: look backwards for "  - .args:" (kernel entry start)
    local start_line=$(head -n $((name_line - 1)) "$temp_meta" | tac | grep -n "^  - \.args:" | head -1 | cut -d: -f1)
    start_line=$((name_line - start_line))
    
    # Find end: look forwards for next "  - .args:" or "amdhsa.version:"
    local next_kernel=$(tail -n +$((name_line + 1)) "$temp_meta" | grep -n "^  - \.args:\|^amdhsa\.version:" | head -1 | cut -d: -f1)
    if [[ -n "$next_kernel" ]]; then
        local end_line=$((name_line + next_kernel - 1))
    else
        local end_line=$(wc -l < "$temp_meta")
    fi
    
    # Extract the metadata
    local metadata=$(sed -n "${start_line},${end_line}p" "$temp_meta")
    rm -f "$temp_meta"
    
    if [[ -z "$metadata" ]]; then
        log "⚠ Failed to extract metadata"
        echo ""
        return
    fi
    
    # Extract key information
    local kernarg_size=$(echo "$metadata" | grep "kernarg_segment_size:" | awk '{print $2}')
    local sgpr_count=$(echo "$metadata" | grep "sgpr_count:" | awk '{print $2}')
    local vgpr_count=$(echo "$metadata" | grep "vgpr_count:" | awk '{print $2}')
    local lds_size=$(echo "$metadata" | grep "group_segment_fixed_size:" | awk '{print $2}')
    local wavefront_size=$(echo "$metadata" | grep "wavefront_size:" | awk '{print $2}')
    local max_workgroup=$(echo "$metadata" | grep "max_flat_workgroup_size:" | awk '{print $2}')
    
    # Count arguments
    local arg_count=$(echo "$metadata" | grep -c "\.offset:")
    
    log "Summary:"
    echo "  Kernel Arguments:      $arg_count (total size: ${kernarg_size:-?} bytes)"
    echo "  Register Usage:        SGPRs: ${sgpr_count:-?}, VGPRs: ${vgpr_count:-?}"
    echo "  LDS Memory:            ${lds_size:-0} bytes"
    echo "  Wavefront Size:        ${wavefront_size:-?}"
    echo "  Max Workgroup Size:    ${max_workgroup:-?}"
    echo ""
    
    # Show arguments in detail
    if [[ $arg_count -gt 0 ]]; then
        log "Kernel Arguments ($arg_count):"
        echo "$metadata" | awk '
        BEGIN { arg_num = 0; name = ""; offset = ""; size = ""; vtype = ""; kind = "" }
        /^      - \./ { 
            # New argument - print previous if exists
            if (arg_num > 0) {
                printf "  [%2d] %-30s offset=%3s size=%2s %-15s (%s)\n", arg_num, name, offset, size, vtype, kind
            }
            arg_num++
            name = ""; offset = ""; size = ""; vtype = ""; kind = ""
        }
        /^        \.name:/ { name = $2 }
        /^        \.offset:/ { offset = $2 }
        /^        \.size:/ { size = $2 }
        /^        \.value_type:/ { vtype = $2 }
        /^        \.value_kind:/ { kind = $2 }
        END { 
            # Print last argument
            if (arg_num > 0) {
                printf "  [%2d] %-30s offset=%3s size=%2s %-15s (%s)\n", arg_num, name, offset, size, vtype, kind
            }
        }
        '
        echo ""
    fi
    
    log "Full Metadata (YAML):"
    echo "$metadata"
    echo ""
}

# Find a kernel by name pattern in multiple .co files
# Usage: find-kernel <kernel_pattern> <path_glob>
# Example: find-kernel "Custom_Cijk_Alik_Bljk_S_MX" "/opt/rocm/lib/hipblaslt/library/*gfx950.co"
# Note: MUST quote the glob pattern to prevent shell expansion
find-kernel() {
    local kernel_pattern="$1"
    local path_glob="$2"
    
    if [[ -z "$kernel_pattern" || -z "$path_glob" ]]; then
        die "Usage: find-kernel <kernel_pattern> <path_glob>\nExample: find-kernel 'Custom_Cijk_Alik' '/opt/rocm/lib/hipblaslt/library/*gfx950.co'\nNote: MUST quote the glob pattern"
    fi
    
    # Check if glob was expanded by shell (unquoted)
    if [[ $# -gt 2 ]]; then
        die "Too many arguments - did you forget to quote the glob pattern?\nUsage: find-kernel 'pattern' '/path/*.co'"
    fi
    
    # Expand glob and collect files
    local co_files=()
    for f in $path_glob; do
        [[ -f "$f" ]] && co_files+=("$f")
    done
    
    local file_count=${#co_files[@]}
    
    log "Searching for kernel matching: $kernel_pattern"
    log "Files to search: $file_count"
    echo ""
    
    local found=0
    local checked=0
    local -a found_files=()  # Array to store files where kernel was found
    
    for co_file in "${co_files[@]}"; do
        if [[ ! -f "$co_file" ]]; then
            continue
        fi
        
        ((checked++))
        local basename=$(basename "$co_file")
        
        # Detect what architecture is bundled in this .co file
        local bundled=$(clang-offload-bundler --list --type=o --input="$co_file" 2>/dev/null)
        if [[ -z "$bundled" ]]; then
            printf "\r\033[K"  # Clear to end of line
            echo "[$checked/$file_count] Skipping $basename (not a valid bundle)"
            continue
        fi
        
        # Extract the architecture (should only be one)
        local target=$(echo "$bundled" | grep "hipv4-amdgcn-amd-amdhsa--gfx" | head -1)
        if [[ -z "$target" ]]; then
            printf "\r\033[K"  # Clear to end of line
            echo "[$checked/$file_count] Skipping $basename (no GPU target found)"
            continue
        fi
        
        local arch=$(echo "$target" | grep -oP 'gfx\d+')
        
        # Unbundle to temp file
        if ! clang-offload-bundler --unbundle --type=o \
            --targets="$target" \
            --input="$co_file" \
            --output=/tmp/find_kernel_temp.elf 2>/dev/null; then
            # Clear line and print error
            printf "\r\033[K"  # \r=return to start, \033[K=clear to end of line
            echo "[$checked/$file_count] Skipping: $basename ($arch) - unbundle failed"
            continue
        fi
        
        # Search for kernel pattern (use -W for wide output to avoid truncation)
        if readelf -sW /tmp/find_kernel_temp.elf 2>/dev/null | grep -q "$kernel_pattern"; then
            # Clear line and print FOUND message
            printf "\r\033[K"  # Clear to end of line
            echo "[$checked/$file_count] Checking: $basename ($arch) ... ✓ FOUND!"
            ((found++))
            found_files+=("$co_file")
        else
            # Overwrite the same line (no newline) - will be overwritten by next iteration
            printf "\r[$checked/$file_count] Checking: $basename ($arch) ... not found"
        fi
    done
    
    # Clear any remaining "not found" message and move to new line
    printf "\r\033[K"  # Clear to end of line
    echo ""
    echo "========================================="
    log "Search Complete"
    echo "========================================="
    
    if [[ $found -eq 0 ]]; then
        log "❌ Kernel pattern '$kernel_pattern' not found in any .co file"
        rm -f /tmp/find_kernel_temp.elf
        return 1
    fi
    
    log "✓ Found kernel in $found file(s):"
    echo ""
    
    # Display detailed results for each found file
    for co_file in "${found_files[@]}"; do
        log "=== Found in: $co_file ==="
        echo ""
        
        # Get architecture
        local bundled=$(clang-offload-bundler --list --type=o --input="$co_file" 2>/dev/null)
        local target=$(echo "$bundled" | grep "hipv4-amdgcn-amd-amdhsa--gfx" | head -1)
        
        # Unbundle to temp file
        clang-offload-bundler --unbundle --type=o \
            --targets="$target" \
            --input="$co_file" \
            --output=/tmp/find_kernel_temp.elf 2>/dev/null
        
        # Show matching kernels (deduplicated)
        log "Matching symbols:"
        readelf -sW /tmp/find_kernel_temp.elf 2>/dev/null | \
            grep "$kernel_pattern" | \
            awk '{$1=""; print}' | \
            sort | uniq
        echo ""
        
        # Count total kernels in this file
        local total_kernels=$(readelf -s /tmp/find_kernel_temp.elf 2>/dev/null | grep -c FUNC)
        log "Total kernels in this file: $total_kernels"
        echo ""
        
        # Get the actual FUNC kernel names (not .kd descriptors)
        local func_kernels=$(readelf -sW /tmp/find_kernel_temp.elf 2>/dev/null | \
            grep " FUNC " | grep "$kernel_pattern" | awk '{print $NF}' | sort | uniq)
        
        # Count how many unique FUNC kernels match
        local func_count=$(echo "$func_kernels" | grep -c .)
        
        # Show detailed metadata for each matching FUNC kernel
        if [[ $func_count -eq 1 ]]; then
            log "Extracting metadata for 1 matching kernel..."
        else
            log "Extracting metadata for $func_count matching kernels..."
        fi
        echo ""
        
        while IFS= read -r func_name; do
            [[ -z "$func_name" ]] && continue
            show-kernel-meta "$func_name" "/tmp/find_kernel_temp.elf"
        done <<< "$func_kernels"
    done
    
    log "✓ To extract kernel: ub-co <input.co> <output.elf> <target>"
    log "✓ To view metadata again: show-kernel-meta '<kernel_name>' <elf_file>"
    
    # Cleanup
    rm -f /tmp/find_kernel_temp.elf
}


