#!/bin/bash
SELF_TAG="[$(basename ${BASH_SOURCE[0]})]"

# List architectures bundled in a .co file
# Usage: list-co <file.co>
list-co() {
    local co_file="$1"
    
    # Check if file argument provided
    if [[ -z "$co_file" ]]; then
        die "No file specified\nUsage: list-co <file.co>"
    fi
    
    # Check if file exists
    if [[ ! -f "$co_file" ]]; then
        die "File not found: $co_file"
    fi
    
    # Display file info
    log "File: $co_file"
    ls -lh "$co_file"
    echo ""
    
    # Check file type
    log "File Type:"
    file "$co_file"
    echo ""
    
    # List bundled architectures
    log "Bundled Architectures:"
    if clang-offload-bundler --type=o --list --input="$co_file" 2>/dev/null; then
        echo ""
        log "✓ File is bundled (use ub-co to extract)"
    else
        die "⚠ Not a bundled file (may already be unbundled ELF)"
    fi
}

# Unbundle a .co file to extract ELF for specific architecture
# Usage: ub-co <input.co> <output.elf> <target>
# Target should be copied from list-co output, e.g.:
#   hipv4-amdgcn-amd-amdhsa--gfx950
ub-co() {
    local input_co="$1"
    local output_elf="$2"
    local target="$3"
    
    # Unbundle
    log "Extracting $target to $output_elf..."
    if ! clang-offload-bundler --type=o --unbundle \
        --targets="$target" \
        --input="$input_co" \
        --output="$output_elf" 2>&1; then
        die "Usage: ub-co <input.co> <output.elf> <target>\n <target> can be copied and pasted from list-co output\n"
    fi
    
    # Verify output
    if [[ ! -f "$output_elf" ]]; then
        die "Output file not created: $output_elf"
    fi
    
    log "✓ Successfully unbundled"
    echo ""
    log "Output file:"
    ls -lh "$output_elf"
    echo ""
    
    log "File type:"
    file "$output_elf"
    echo ""
    
    # Count kernels
    local kernel_count=$(readelf -s "$output_elf" 2>/dev/null | grep FUNC | wc -l)
    log "Kernel count: $kernel_count"
    
    log "✓ Done! Use 'readelf -sW $output_elf | grep FUNC' to list kernels"
}

# Find a kernel by name pattern in multiple .co files
# Usage: find-kernel <kernel_pattern> <path_glob>
# Example: find-kernel "Custom_Cijk_Alik_Bljk_S_MX" "/opt/rocm/lib/hipblaslt/library/*gfx950.co"
# Note: MUST quote the glob pattern to prevent shell expansion
find-kernel() {
    local kernel_pattern="$1"
    local path_glob="$2"
    
    if [[ -z "$kernel_pattern" || -z "$path_glob" ]]; then
        die "Usage: find-kernel <kernel_pattern> <path_glob>\nExample: find-kernel 'Custom_Cijk_Alik' '/opt/rocm/lib/hipblaslt/library/*gfx950.co'\nNote: MUST quote the glob pattern"
    fi
    
    # Check if glob was expanded by shell (unquoted)
    if [[ $# -gt 2 ]]; then
        die "Too many arguments - did you forget to quote the glob pattern?\nUsage: find-kernel 'pattern' '/path/*.co'"
    fi
    
    # Expand glob and collect files
    local co_files=()
    for f in $path_glob; do
        [[ -f "$f" ]] && co_files+=("$f")
    done
    
    local file_count=${#co_files[@]}
    
    log "Searching for kernel matching: $kernel_pattern"
    log "Files to search: $file_count"
    echo ""
    
    local found=0
    local checked=0
    local -a found_files=()  # Array to store files where kernel was found
    
    for co_file in "${co_files[@]}"; do
        if [[ ! -f "$co_file" ]]; then
            continue
        fi
        
        ((checked++))
        local basename=$(basename "$co_file")
        
        # Detect what architecture is bundled in this .co file
        local bundled=$(clang-offload-bundler --list --type=o --input="$co_file" 2>/dev/null)
        if [[ -z "$bundled" ]]; then
            printf "\r%-120s\r" ""  # Clear line
            echo "[$checked/$file_count] Skipping $basename (not a valid bundle)"
            continue
        fi
        
        # Extract the architecture (should only be one)
        local target=$(echo "$bundled" | grep "hipv4-amdgcn-amd-amdhsa--gfx" | head -1)
        if [[ -z "$target" ]]; then
            printf "\r%-120s\r" ""  # Clear line
            echo "[$checked/$file_count] Skipping $basename (no GPU target found)"
            continue
        fi
        
        local arch=$(echo "$target" | grep -oP 'gfx\d+')
        
        # Unbundle to temp file
        if ! clang-offload-bundler --unbundle --type=o \
            --targets="$target" \
            --input="$co_file" \
            --output=/tmp/find_kernel_temp.elf 2>/dev/null; then
            # Use \r to overwrite the line, clear with spaces, then overwrite again
            printf "\r%-120s\r" ""  # Clear line
            echo "[$checked/$file_count] Skipping: $basename ($arch) - unbundle failed"
            continue
        fi
        
        # Search for kernel pattern (use -W for wide output to avoid truncation)
        if readelf -sW /tmp/find_kernel_temp.elf 2>/dev/null | grep -q "$kernel_pattern"; then
            # Clear the line first, then print FOUND message with newline
            printf "\r%-120s\r" ""  # Clear line
            echo "[$checked/$file_count] Checking: $basename ($arch) ... ✓ FOUND!"
            ((found++))
            found_files+=("$co_file")
        else
            # Overwrite the same line (no newline) - will be overwritten by next iteration
            printf "\r[$checked/$file_count] Checking: $basename ($arch) ... not found"
        fi
    done
    
    # Clear any remaining "not found" message and move to new line
    printf "\r%-120s\r" ""
    echo ""
    echo "========================================="
    log "Search Complete"
    echo "========================================="
    
    if [[ $found -eq 0 ]]; then
        log "❌ Kernel pattern '$kernel_pattern' not found in any .co file"
        rm -f /tmp/find_kernel_temp.elf
        return 1
    fi
    
    log "✓ Found kernel in $found file(s):"
    echo ""
    
    # Display detailed results for each found file
    for co_file in "${found_files[@]}"; do
        log "=== Found in: $co_file ==="
        echo ""
        
        # Get architecture
        local bundled=$(clang-offload-bundler --list --type=o --input="$co_file" 2>/dev/null)
        local target=$(echo "$bundled" | grep "hipv4-amdgcn-amd-amdhsa--gfx" | head -1)
        
        # Unbundle to temp file
        clang-offload-bundler --unbundle --type=o \
            --targets="$target" \
            --input="$co_file" \
            --output=/tmp/find_kernel_temp.elf 2>/dev/null
        
        # Show matching kernels (deduplicated)
        log "Matching symbols:"
        readelf -sW /tmp/find_kernel_temp.elf 2>/dev/null | \
            grep "$kernel_pattern" | \
            awk '{$1=""; print}' | \
            sort | uniq
        echo ""
        
        # Count total kernels in this file
        local total_kernels=$(readelf -s /tmp/find_kernel_temp.elf 2>/dev/null | grep -c FUNC)
        log "Total kernels in this file: $total_kernels"
        echo ""
    done
    
    log "✓ Use 'ub-co <input.co> <output.elf> <target>' to extract kernel for analysis"
    
    # Cleanup
    rm -f /tmp/find_kernel_temp.elf
}


